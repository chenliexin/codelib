
## 性能优化
- 雅虎军规
    - 尽量减少HTTP请求数
        - 合并文件
        - 雪碧图css sprites
        - base64编码行内图片
    - 减少DNS查找
        - 减少主机名数目
        - 主机名数目减少会导致并行下载能力下降，在页面引用资源较多的时候考虑使用2-4个主机名较为合适
    - 避免重定向
        - 使用的话建议301、302
        - 不建议meta标签的http-equiv="refresh"
    - 让Ajax可缓存
        - 使用gzip
        - 减少DNS查找
        - 压缩JavaScript
        - 避免重定向
        - 配置ETag
    - 延迟加载组件
        - 仔细观察什么是一开始必须加装，什么是可以等待
        - 图片懒加载
    - 预加载组件
        - 无条件预加载
        - 条件性预加载，例如是搜索栏输入时候预判加载，例如预加载分页器的下一页
        - 提前预加载，例如改版时候可以将新的资源放进旧版本用于缓存
    - 减少DOM元素的数量
    - 跨域分离组件
        - 最大化并行下载
        - 只用不超过2-4个域，因为存在DNS查找的代价
    - 尽量少用iframe
        - 优点：方便使用第三方；安全沙箱；并行下载脚本
        - 缺点：阻塞页面加载；非语义化
    - 避免使用css表达式
    - 使用link标签而不是@import
    - 避免使用滤镜
    - 把样式放在头部
    - 尽量减少DOM访问和操作
        - 减少DOM访问，DOM访问是昂贵的、是性能主要瓶颈
            - 避免中循环中进行DOM访问
            - 将DOM赋值给局部变量
            - 善用ID和selector API
        - 减少DOM更新，更新DOM导致的重绘，是巨大的开销
            - 分批处理更新
            - 使用替换而不是修改
    - 使用事件委派／广播的方式获得，而不是直接绑定
    - 把脚本放在底部
        - 脚本会阻塞并行下载
        - 使用defer和async
    - 外链js和css
        - 可以缓存
    - 压缩js和css
    - 优化图片
        - 图片类型的选择
        - 图片压缩
    - 优化CSS Sprite
        - 横向排列比纵向排列要小
        - 可以使用png8格式
        - 不要留太大缝隙
    - 不要用html去缩放图片
    - 用小的、可缓存的favicon.ico
        - 1k以内
        - 长期缓存
    - 优化cookie
        - 清除不必要的cookie
        - 给cookie设置子域名，避免其他子域名
        - 设置合适的有效期
    - 把静态资源放在不含cookie的域下
    - 保证所有组件都小于25K在移动端
    - 使用gzip
    - 避免图片src属性为空
    - 配置ETags
    - 对Ajax用GET请求
    - 使用CDN（内容分发网络）
    - 添上Expires或者Cache-Control HTTP头

## 设计模式

- 单体模式singleton
    - 一个特定类仅有一个实例
    - 应用：全局保护
- 工厂模式factory
    - 用于实例化多个相似的对象
    - 应用：汽车通用类，以及通过参数实例化成各个类别的汽车
- 迭代器模式
    - 包含某种数据集合的对象，提供一种简单访问该集合每个元素的方法
    - 通常包含next()，hasNext()，rewind()，current()等方法
    - 应用：日历
- 装饰者模式decorate
    - 可以中运行时动态附加功能到对象中
    - 其预期行为有可制定和可配置特性
    - 按照顺序进行装饰
    - 应用：商品为一个基本对象，对商品进行打折、运费等多次装饰
- 策略模式
    - 使用同一个接口，根据上下文即参数，选择特定的算法。
    - 应用：表单验证
- 外观模式
    - 提供一个可供选择的接口，处理同一目的，但不同环境中需要不同处理的事务
    - 应用：浏览器兼容性封装，如事件冒泡、阻止默认行为
- 代理模式
    - 一个对象充当另一个对象的接口
    - 这种方法看起来像是额外开销，但如果出于性能因素而考虑它却是非常有用的
    - 应用：一个巨大的第三方工具库，如果引入但是却用不到那是非常浪费的，可以通过一个代理对象，当用到的是动态引入工具库
- 中介者模式
    - 作为多个对象间相互通信的中间节点，从而减少耦合性，提高代码可维护性
    - 应用：动态积分榜单
- 观察者模式observer
    - 又称订阅／发布模式
    - 一个对象订阅另一个对象的活动状态，并在状态改变后收到通知。
    - 应用：浏览器事件

## 数据结构
- 数组
    - 线性集合，语言内置，性能高
    - 迭代器方法
    - 多维数组
- 列表
    - 有序数据集合
    - 通常连带实现增删查改功能
    - 迭代器方法
- 栈
    - 后入先出的数据结构
    - 入栈出栈
- 队列
    - 先入先出的数据结构
    - 入队出队
    - 通常连带实现清空、取队头等方法
- 链表
    - 一组节点集合
    - 插入删除高效
- 字典
    - 键值对数据结构
    - js的Object就是字典
- 散列
    - 插入、删除、取值很快；查找很慢，如查最大最小
    - 键通过散列函数映射为一个数字
- 集合
    - 包含不同元素的数据结构
    - 无序
    - 不允许重复




### MVC MVP MVVM

按照模式出现的`时间顺序`，先是 `MVC` 。 `Model 模型`负责提供数据、 `View 视图`负责界面显示、 `Controller 控制器`负责逻辑处理。

典型的 MVC 流程：用户通过 View 或 直接向 Controller 发出指令， Controller 完成业务逻辑后，要求 Model 改变状态， Model 将新的数据发送到 View ，用户得到响应。 

MVC 的最大特点就是所有通信都是`单向`的，因此，将 MVC 用于前端开发的话会导致两个问题：一是 View 包含了业务逻辑，二是 Controller 会变得非常复杂。

`MVP` 是 MVC 的一个演变模式， `Presenter 表示器`负责界面逻辑处理，从而解决 MVC 的第一个问题。Presenter 串联起 View 与 Model 的通信，且所有通信都是`双向`的。

`MVVM` 与 MVP 基本上相同，而不同之处在于 `ViewModel 视图模型`和 View 之间采用`双向绑定`，从而解决了MVC的第二个问题，目前流行的三大前端框架均采用这种方式。

技术选项的关键在于业务，单纯展示性的 web 应用可以采用 MVC 模式的 nodejs 服务；强视图交互的 web 应用可以采用 MVP 模式来统一管理逻辑；强数据交互的 web 应用则可以采用 MVVM 模式来减少渲染逻辑。





### 模块化

CommonJS 同步加载，如nodejs

AMD 异步模块定义 define(['dep1','dep2'],function(dep1,dep2){...})，如require.js和curl.js。

CMD 通用模块定义 define(function(require,exports,module){...})，如seajs，更贴近 CommonJS Modules/1.1 和 Node Modules 规范。

SeaJS对模块的态度是懒执行, 而RequireJS对模块的态度是预执行


# 安全
- 跨站脚本攻击
  - XSS cross site scripting，避免与CSS缩写冲突
- XSS
  - cross-site scripting跨域脚本攻击，javascript代码注入
  - 防御：过滤，避免运行用户代码，cookis用httpOnly等
- CSRF/XSRF
  - Cross-site request forgery 跨站请求伪造
  - 防御：检查来路同域、做token等
- 其他：界面劫持、http劫持等
